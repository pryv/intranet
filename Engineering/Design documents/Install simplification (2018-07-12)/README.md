|         |                       |
| ------- | --------------------- |
| Author  | Thi√©baud Modoux 	  |
| Date    | 07.12.2018            |
| Version | 1                     |

# Simplifiying Pryv installation: minimal configuration and first steps

Through this document, we aim to think about and provide some tracks to simplify the first necessary steps for installing and configuring a Pryv platform.

## Scope

We plan to introduce the following changes: 
- add a minimal, self-documenting user-facing configuration
- add a service for converting minimal configuration to production configuration
- distinguish standard configuration values and secrets

Each of these points will be discussed below. At the end of this document, we reserve a chapter about some other points that we would have liked to work on but that leave the scope of this project.

### Add a minimal, self-documenting user-facing configuration

The first obstacle for clients deploying a Pryv platform is to go through a lot of configuration files, which contain too much undocumented settings.

An essential simplification step would be to present lightweight configuration to the user, which consists of the minimal configuration values, each of which will be accurately documented (e.g. [redis conf](http://download.redis.io/redis-stable/redis.conf)).

We try here to list the minimal settings of a Pryv platform and sort them among the below subsections:

### Add a service for converting minimal configuration

We would need a script/tool/service that converts the user-facing configuration to the more complex configuration files and distributes/sync them to respective containers (core/hfs/influxdb/mail/mongodb/preview, register/dns/redis, static/nginx).

This task basically resumes at reading a set of key-value in the simplified configuration file (json) and replacing string placeholders in template configuration files (also json). It can reasonably be implemented as a bash script and a basic CL tool (see [jq](https://stedolan.github.io/jq/) or sed/awk/grep). [This article](http://steveadams.io/2016/08/18/Environment-Variable-Templates.html) presents some interesting approachs.

Note that there is multiple template files (about 10) to replace with the same input file, cluster template having more files to replace than single-node. 

### Distinguish standard configuration values and secrets

Another key step in configuring a Pryv platform is the generation, exchange and storage of secrets, such as SSH keys, API keys, symmetric keys or SSL certificates. For now, most of these secrets have to be generated by the sysadmin installing the platform and are provided alongside with the configuration files. This is neither convenient nor secure.

Ideally, we should find some ways to have the different containers generate and exchange automatically the necessary secrets and make sure they are kept in a safe place. Known good practices for provisionning containers with secrets include: env variables, conf files, etcd (or similar services), docker secrets or external services.

Finally, here is a summary of all the secrets currently necessary to run a Pryv platform, which span in two categories:

1. Shared secrets
    - Core <=> Mail symmetric key
    - Core <=> Register symmetric key (adminAccessKey)
2. Container-specific secrets
    - SSL certificates (static web, nginx)
    - Admin/system keys (register)
    - ssoCookie signin secret and token (register)

## Annex

### What we would like to do but will not
- containers will still start with the same configuration files
- we do not improve the safety of how we keep secrets, but make it possible
- we do not generate symmetric keys
- automatic secrets generation/exchange

Since register machines have to be able to contact core machines, it could be great to have a 'service discovery' step at launch, during which registers contact cores and exchange symmetric keys (D-H?).

The generation and management of a specific set of secrets, the SSL certificates, could also be simplified but will be part of a separated task.

Also, there are admin and system keys which are used to restrict some API calls to a subset of users, generally the system administrators. Could these keys be equal/similar to SSH keys? Could we use [mutual authentification](https://medium.com/@sevcsik/authentication-using-https-client-certificates-3c9d270e8326)?

### Typical values for user-facing configuration

#### Docker-compose settings (YML files)
- Version number of docker images
- Volumes (conf, logs, data) => define all subsequent dir paths
- Ports exposed

#### Core/preview settings
- Ignoreprotectedfields for updates
- Audit: forcekeephistory, deletion mode
- Auth: trusted apps, sessionmaxage, password reset request max age
- Eventtypes url (github.io)
- ? Nightlyscript crontime

#### Register settings
- Hostings: cores urls (cr1.domain), regions/zones/url,name,description
- Invitations tokens list
- ? AppList: name, description, icon, url

#### DNS settings
- Domain, additional domains (?)
- CAA issuer
- NS: dns IPs
- Machines IPs (cores, reg-master/slave, mail?), aliases
- ? Website IP

#### Access settings (pages)
- sw.domain/access/access.html
- sw.domain/access/reset-password.html
- sw.domain/access/register.html

#### Mailing settings
- Activation (welcome, reset)
- Method (mandrill, microservice)
- Send URL (API/service endpoint)
- From name/address
- SMTP: host, port, credentials
- Sendmail: activation, path to cmd
- DefaultLang
- Templates (files, names)

#### Redis settings
- Example config

#### NGINX settings
- server_name (reg.domain, access.domain)
- pryv.github.io/app-web/
- pryv.github.io/app-web-auth3/
- upstreams

#### Logs settings
- Where: Mongo, mail, core
- Options: File/console, append, enable, prefix, level
- Hfs trace: enable, agent host

#### HTTP settings
- Where: Mail, hfs/Metadataupdater, redis, dns, core, preview, register
- Options: Ip, port, host, ssl

#### Mongo
- Host, port
- Db name

#### Optional ?
- AIBRAKE: active, projectid/key (reg, core)
- ENV: prod/dev

### Tools

|    Tool     |  Notes     |
| ------- | --------------------- |
| Jq    | Lightweight and flexible command-line JSON processor. It is like sed/awk/grep for JSON data. |
| Etcd    | Distributed key-value store for the most critical data of a distributed system, simple but powerful when used with [Registrator](http://gliderlabs.github.io/registrator/latest/) (service discovery) and [confd](http://www.confd.io/) (config management). It's a modular DIY solution. |
| Ansible | Provisioning, Configuration Management, App Deployment, Continuous Delivery, Security & Compliance, Orchestration. [Fit particularly well with Docker](https://medium.com/@cabot_solutions/ansible-and-docker-the-best-combination-for-an-efficient-software-product-management-28c86cfebe90) and can manage secrets through [Vault](https://docs.ansible.com/ansible/latest/user_guide/playbooks_vault.html#id3). |
| Hashicorp: terraform | Building, changing, and versioning infrastructure. Also fit well with Docker. |
| Hashicorp: vault | Secure, store and tightly control access to tokens, passwords, certificates, encryption keys for protecting secrets and other sensitive data using a UI, CLI, or HTTP API. |
| Hashicorp: consul | Service discovery, segmentation and configuration. Also fit well with [Registrator](http://gliderlabs.github.io/registrator/latest/) (service discovery) and [confd](http://www.confd.io/) (config management) |
| Hashicorp: packer | Provision and build Docker containers with [Docker Builder](https://www.packer.io/docs/builders/docker.html). It can also be further [combined with Ansible](https://techdev.io/en/developer-blog/building-docker-images-with-packer-and-ansible). |
| Kubernetes | Service discovery and load balancing, Automatic binpacking, Storage orchestration, Self-healing, Automated rollouts and rollbacks, Secret and configuration management, Batch execution, Horizontal scaling. |
| Docker | [Docker configuration](https://docs.docker.com/engine/swarm/configs/) and [Docker secrets](https://docs.docker.com/engine/swarm/secrets). |

